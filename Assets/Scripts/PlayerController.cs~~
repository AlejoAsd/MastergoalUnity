using UnityEngine;
using System.Collections;

public enum EstadoJuego
{
    Juego,
    Pase,
    Movimiento,
    Reiniciando,
    Fin
}

public enum Equipo
{
    Blanco = -1,
    Ninguno,
    Rojo,
    Ambos
}

public enum TipoFicha
{
    Vacio,
    Pelota,
    BlancoFicha,
    BlancoArquero,
    RojoFicha,
    RojoArquero
}

public class BoardCell
{
    public int x;
    public int y;
    public TipoFicha ficha;
    public Equipo equipo;
    public int influenciaBlanco;
    public int influenciaRojo;
    public bool area;
    public bool corner;
    public bool arco;
    public bool especial;
    public bool arquero;
    
    public BoardCell(int alto, int ancho, int x, int y)
    {
        this.x = x;
        this.y = y;
        
        influenciaBlanco = 0;
        influenciaRojo = 0;
        
        arquero = false;
        
        // Calcular las propiedades del tablero
        // Definir el equipo
        if (x < (alto / 2))
            equipo = Equipo.Blanco;
        else if (x > (alto / 2))
            equipo = Equipo.Rojo;
        else
            equipo = Equipo.Ninguno;
        
        // Definir si es un corner
        corner = (x == 1 || x == (alto - 2)) && (y == 0 || y == (ancho - 1));
        
        // Definir si es parte del área
        area = ((x >= 1 && x <= 4) || (x >= (alto - 5) && x <= (alto - 2))) && 
            (y >= 1 && y <= (ancho - 2));
        
        // Definir si es un arco
        arco = x == 0 || x == (alto - 1);
        
        // Definir si es una casilla especial
        especial = (x == 1 || x == (alto - 2)) && 
            (y == 0 || y == (ancho - 1) || (y >= 3 && y <= 7));
    }
    
    /*
     * Indica si la influencia de los equipos se neutraliza en la casilla.
     * Una casilla sin influencia tambien es considerada neutral.
     * En caso de querer estar seguro que no hay ningún tipo de influencia en la casilla usar InfluenciaCero().
     */
    public bool influenciaNeutra()
    {
        return (influenciaRojo - influenciaBlanco) == 0;
    }
    
    /*
     * Indica si la casilla no esta bajo influencia alguna
     */
    public bool influenciaCero()
    {
        return influenciaRojo == 0 && influenciaBlanco == 0;
    }
    
    /*
     * Indica si un equipo tiene posesion de esta casilla.
     * Parámetros:
     * Equipo - Equipo sobre el que se valora la influencia
     * Estricto - Define el nivel de influencia que se debe tener para tener posesion.
     * Retorna: 
     * true si hay un empate o mayoria de influencia del equipo en el caso no estricto.
     * true si hay mayoría de influencia del equipo en el caso estricto.
     */
    public bool tieneInfluencia(Equipo equipo, bool estricto)
    {
        if (estricto)
        {
            return ((influenciaRojo - influenciaBlanco) * (int)equipo) > 0;
        } else
        {
            return ((influenciaRojo - influenciaBlanco) * (int)equipo) >= 0;
        }
    }

    public void modificarInfluencia(TipoFicha ficha, bool inverso)
    {
        int Cantidad = 1 * (inverso ? -1 : 1);
        
        if (ficha == TipoFicha.BlancoArquero || ficha == TipoFicha.RojoArquero)
        {
            Cantidad *= 6;
        }

        if (ficha == TipoFicha.BlancoFicha || ficha == TipoFicha.BlancoArquero)
        {
            influenciaBlanco += Cantidad;
        } else if (ficha == TipoFicha.RojoFicha || ficha == TipoFicha.RojoArquero)
        {
            influenciaRojo += Cantidad;
        }
    }
}

public class PlayerController : MonoBehaviour
{

    // Dimensiones del tablero
    static int ancho = 11, alto = 15, anchoArco = 5;
    static int contadorTurnos = 0, pases = 0, pasesMaximos = 4;

    // Matriz que representa el tablero de juego
    public static BoardCell[,] board = new BoardCell[alto, ancho]; 
    
    // Posicion de ficha y posicion destino
    int fichaX, fichaY, ballX, ballY, destinoX, destinoY;

    // Variable que almacena el tag de la ficha seleccionada
    string selected = null;
    public static bool ballSelected = false;

    // Para manejo de turno
    public static Equipo turno = Equipo.Blanco;
    //NetworkView networkView;
    
    void Start()
    {
        // Cargo la matriz con 0s (celdas vacias)
        for (int i = 0; i < alto; i++)
        {
            for (int j = 0; j < ancho; j++)
            {
                board [i, j] = new BoardCell(alto, ancho, i, j);
                board [i, j].ficha = TipoFicha.Vacio;
            }
        }

        // Cargo la matriz con los valores segun el nivel
        switch (MenuController.level)
        {
            case 1:
                board [10, 5].ficha = TipoFicha.BlancoFicha;
                board [4, 5].ficha = TipoFicha.RojoFicha;
                break;
            case 2:
                board [10, 5].ficha = TipoFicha.BlancoFicha;
                board [12, 5].ficha = TipoFicha.BlancoFicha;
                board [4, 5].ficha = TipoFicha.RojoFicha;
                board [2, 5].ficha = TipoFicha.RojoFicha;
                break;
            case 3:
                board [8, 2].ficha = TipoFicha.BlancoFicha;
                board [8, 8].ficha = TipoFicha.BlancoFicha;
                board [10, 3].ficha = TipoFicha.BlancoFicha;
                board [10, 7].ficha = TipoFicha.BlancoFicha;
                board [12, 5].ficha = TipoFicha.BlancoArquero;

                board [6, 2].ficha = TipoFicha.RojoFicha;
                board [6, 8].ficha = TipoFicha.RojoFicha;
                board [4, 3].ficha = TipoFicha.RojoFicha;
                board [4, 7].ficha = TipoFicha.RojoFicha;
                board [2, 5].ficha = TipoFicha.RojoArquero;
                break;
        }
        board [7, 5].ficha = TipoFicha.Pelota;

        // Para manejo de turno
        //networkView = GetComponent<NetworkView> ();
        //turn = 1;
    }

    void Update()
    {   
        if (GetComponent<NetworkView>().isMine)
        {
            InputMovement();
        }

        if (Network.peerType == NetworkPeerType.Disconnected)
            Network.Destroy(GetComponent<NetworkView>().viewID);
    }
    
    void InputMovement()
    {
        if (Input.GetMouseButtonDown(0))
        {
            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
            RaycastHit hit;
            if (Physics.Raycast(ray, out hit, Mathf.Infinity))
            {

                if (Network.peerType == NetworkPeerType.Server /*&& turn == 1*/)
                {

                    if (ballSelected == false)
                    {
                        // Selecciono o deselecciono la ficha presionada
                        if (hit.collider.tag == "P1F1")
                        {
                            selectDeselectPiece("P1F1");
                        }

                        if (hit.collider.tag == "P1F2")
                        {
                            selectDeselectPiece("P1F2");
                        }

                        if (hit.collider.tag == "P1F3")
                        {
                            selectDeselectPiece("P1F3");
                        }

                        if (hit.collider.tag == "P1F4")
                        {
                            selectDeselectPiece("P1F4");
                        }

                        if (hit.collider.tag == "P1F5")
                        {
                            selectDeselectPiece("P1F5");
                        }

                        // Selecciona una casilla a donde se movera la ficha seleccionada
                        if (hit.collider.tag == "Box" && selected != null)
                        {
                            movePiece(hit);
                        }
                    } else
                    {
                        if (hit.collider.tag == "Box")
                        {
                            moveBall(hit);
                        }
                    }
                }

                if (Network.peerType == NetworkPeerType.Client /*&& turn == 2*/)
                {
                    if (ballSelected == false)
                    {
                        // Selecciono o deselecciono la ficha presionada
                        if (hit.collider.tag == "P2F1")
                        {
                            selectDeselectPiece("P2F1");
                        }
                            
                        if (hit.collider.tag == "P2F2")
                        {
                            selectDeselectPiece("P2F2");
                        }

                        if (hit.collider.tag == "P2F3")
                        {
                            selectDeselectPiece("P2F3");
                        }

                        if (hit.collider.tag == "P2F4")
                        {
                            selectDeselectPiece("P2F4");
                        }

                        if (hit.collider.tag == "P2F5")
                        {
                            selectDeselectPiece("P2F5");
                        }

                        // Selecciona una casilla a donde se movera la ficha seleccionada
                        if (hit.collider.tag == "Box" && selected != null)
                        {
                            movePiece(hit);
                        }
                    } else
                    {
                        if (hit.collider.tag == "Box")
                        {
                            moveBall(hit);
                        }
                    }
                }
            }
        }
    }

    // Selecciona o deselecciona una ficha
    void selectDeselectPiece(string tag)
    {
        if (selected == null)
        {
            GameObject.FindWithTag(tag).GetComponent<Renderer>().material.color = Color.blue;
            selected = tag;
        } else
        {   
            if (selected == tag)
            {
                if (Network.peerType == NetworkPeerType.Server)
                    GameObject.FindWithTag(tag).GetComponent<Renderer>().material.color = Color.white;
                else
                    GameObject.FindWithTag(tag).GetComponent<Renderer>().material.color = Color.red;
                selected = null;
            }
        }
    }

    // Selecciona la casilla a donde mover la ficha, verifica si es un movimiento valido, y mueve la ficha
    void movePiece(RaycastHit hit)
    {
        // Obtengo la posicion de la ficha
        fichaX = GameObject.FindWithTag(selected).GetComponent<MatrixAttributes>().x;
        fichaY = GameObject.FindWithTag(selected).GetComponent<MatrixAttributes>().y;
        
        // Obtengo la posicion destino
        destinoX = GameObject.Find(hit.collider.name).GetComponent<MatrixAttributes>().x;
        destinoY = GameObject.Find(hit.collider.name).GetComponent<MatrixAttributes>().y;
        
        // Verifico si es un movimiento valido
        if (validarMovimiento(fichaX, fichaY, destinoX, destinoY))
        {
            // Cargo nuevos valores en la matriz
            GetComponent<NetworkView>().RPC("setMatrix", RPCMode.All, fichaX, fichaY, destinoX, destinoY);
            // Muevo la ficha
            GameObject.FindWithTag(selected).GetComponent<MatrixAttributes>().x = destinoX; 
            GameObject.FindWithTag(selected).GetComponent<MatrixAttributes>().y = destinoY;
            GameObject.FindWithTag(selected).transform.position = hit.collider.transform.position;
            if (Network.peerType == NetworkPeerType.Server)
                GameObject.FindWithTag(selected).GetComponent<Renderer>().material.color = Color.white;
            else
                GameObject.FindWithTag(selected).GetComponent<Renderer>().material.color = Color.red;
            selected = null;

            // En caso que se encuentre en una posicion adyacente a la pelota, pasar a modo pase
            if (getBall(destinoX, destinoY))
            { 
                ballSelected = true;
                //selected = "BALL";
                GameObject.FindWithTag("BALL").GetComponent<Renderer>().material.color = Color.blue;
            }
            //networkView.RPC ("setTurn", RPCMode.All);
        }
    }

    void moveBall(RaycastHit hit)
    {
        // Obtengo la posicion de la ficha
        ballX = GameObject.FindWithTag("BALL").GetComponent<MatrixAttributes>().x;
        ballY = GameObject.FindWithTag("BALL").GetComponent<MatrixAttributes>().y;
        
        // Obtengo la posicion destino
        destinoX = GameObject.Find(hit.collider.name).GetComponent<MatrixAttributes>().x;
        destinoY = GameObject.Find(hit.collider.name).GetComponent<MatrixAttributes>().y;
        
        // Verifico si es un movimiento valido
        if (validarMovimiento(ballX, ballY, destinoX, destinoY))
        {
            // Muevo la pelota, pinto y cargo los valores en la matriz tanto en el servidor como en el cliente
            GetComponent<NetworkView>().RPC("moveBallOnServerAndClient", RPCMode.All, destinoX, destinoY, hit.collider.transform.position, ballX, ballY);       
            /*selected = null;
            ballSelected = false;*/
            // if (ficha alrededor de la pelota){
            //ballSelected = true;  
            //GameObject.FindWithTag("BALL").GetComponent<Renderer>().material.color = Color.blue;
            //}
            //networkView.RPC ("setTurn", RPCMode.All);
        }
    }

    // Verifica si el movimiento a realizar es valido
    bool validarMovimiento(int fichaX, int fichaY, int destinoX, int destinoY)
    {
        int arcoOffset = (ancho - anchoArco) / 2;
        string mensaje;
        BoardCell ficha = board [fichaX, fichaY];
        BoardCell destino = board [destinoX, destinoY];
        
        /// Validar destino
        // Asegurar que esté dentro del tablero. Los tableros cuentan como fuera del arco excepto en el caso de la pelota.
        if (destinoX < 0 || destinoX >= alto ||
            destinoY < 0 || destinoY >= ancho)
        {
            mensaje = "Casilla invalida";
            //mensajeError(mensaje);
            return false;
        }
        
        // Asegurar que exista una casilla para la posición indicada
        if (ficha.ficha != TipoFicha.Pelota && 
            (destinoX == 0 || destinoX == (alto - 1)) &&
            (destinoY >= arcoOffset || destinoY <= arcoOffset + anchoArco))
        {
            mensaje = "Los jugadores no pueden entrar al arco";
            //mensajeError(mensaje);
            return false;
        }
        
        // Asegurar que no sea un corner del equipo
        if (ficha.ficha == TipoFicha.Pelota && turno == destino.equipo &&
            destino.corner)
        {
            mensaje = "No se puede mover a un corner propio";
            //mensajeError(mensaje);
            return false;
        }
        
        // Asegurar que al mover la pelota la casilla pertenezca al equipo de turno
        if (ficha.ficha == TipoFicha.Pelota && !destino.tieneInfluencia(turno, false))
        {
            mensaje = "La pelota no puede terminar en posesion del oponente";
            //mensajeError(mensaje);
            return false;
        }
        
        // Asegurar que la pelota termine en una casilla neutra
        if (ficha.ficha == TipoFicha.Pelota &&
            pases == pasesMaximos &&
            !destino.influenciaNeutra())
        {
            mensaje = "Solo queda un pase disponible. La pelota debe quedar en una casilla neutra";
            //mensajeError(mensaje);
            return false;
        }
        
        // Asegurar que la pelota no termine del lado del jugador que saca en el primer turno
        if (contadorTurnos == 1 &&
            pases == pasesMaximos &&
            turno == destino.equipo)
        {
            mensaje = "La pelota no puede terminar del lado del equipo que empieza";
            //mensajeError(mensaje);
            return false;
        }
        
        /// Validar movimiento
        int deltaDestinoX = System.Math.Abs(destinoX - ficha.x);
        int deltaDestinoY = System.Math.Abs(destinoY - ficha.y);
        int maximoMovimientos = ficha.ficha == TipoFicha.Pelota ? 4 : 2;
        
        // El movimiento es en línea recta
        if ((!deltaDestinoX && !deltaDestinoY) ||
            (deltaDestinoX && deltaDestinoY &&
            deltaDestinoX != deltaDestinoY))
        {
            mensaje = "El movimiento debe ser recto";
            //mensajeError(mensaje);
            return false;
        }
        
        // El movimiento está dentro del rango de la ficha
        if (deltaDestinoX > maximoMovimientos ||
            deltaDestinoY > maximoMovimientos)
        {
            mensaje = "No se puede desplazar esa cantidad de casillas";
            //mensajeError(mensaje);
            return false;
        }
        
        // La casilla objetivo está ocupada
        if (destino.ficha != TipoFicha.Vacio)
        {
            bool valido = false;
            
            // Excepción para permitir a un arquero moverse a los costados
            if (ficha.EsArquero(false) &&
                deltaDestinoX == 0 && deltaDestinoY == 1 &&
                (destinoY > 0 &&
             board[destinoX, destinoY - deltaDestinoY].ficha == TipoFicha.Vacio ||
                (board[destinoX, destinoY - deltaDestinoY].ficha == TipoFicha.Pelota ||
                board[destinoX, destinoY - deltaDestinoY].ficha == ficha.ficha)) &&
                (destinoY < (ancho - 1) &&
             board[destinoX, destinoY + deltaDestinoY].ficha == TipoFicha.Vacio ||
             board[destinoX, destinoY + deltaDestinoY].ficha == TipoFicha.Pelota ||
                board[destinoX, destinoY + deltaDestinoY] == ficha.ficha))
            {
                valido = true;
            }
            
            if (!valido)
            {
                mensaje = "Se debe mover a una casilla libre";
                //mensajeError(mensaje);
                return false;
            }
        }
        // La casilla objetivo está libre
        else
        {
            // No permitir a un arquero mover a una casilla donde hayan fichas adyacentes
            if (ficha.EsArquero(false) &&
                ((destinoY > 0 &&
                board[destinoX, destinoY - 1] != TipoFicha.Vacio &&
                board[destinoX, destinoY - 1] != TipoFicha.Pelota &&
                board[destinoX, destinoY - 1] != ficha.ficha &&
                board[destinoX, destinoY - 1] != (ficha.ficha + 1)) ||
                (destinoY < (ancho - 1) &&
                board[destinoX, destinoY + 1] != TipoFicha.Vacio &&
                board[destinoX, destinoY + 1] != TipoFicha.Pelota &&
                board[destinoX, destinoY + 1] != ficha.ficha &&
                board[destinoX, destinoY + 1] != (ficha.ficha + 1))))
            {
                mensaje = "Una casilla adyacente no se encuentra libre";
                //mensajeError(mensaje);
                return false;
            }
        }
        
        // Asegurar que no sea un autopase
        if (ficha.ficha == TipoFicha.Pelota)
        {
            BoardCell fichaPase = obtenerEstadoCelda(ficha.x, ficha.y);
            BoardCell fichaReceptora = obtenerEstadoCelda(destinoX, destinoY);
            
            if (fichaPase != null && fichaPase == fichaReceptora)
            {
                mensaje = "No se puede hacer un autopase";
                //mensajeError(mensaje);
                return false;
            }
        }
        
        // Asegurar que el movimiento del jugador no rompa el balance de influencia
        /*FVector2D DeltaOrigen = FVector2D(TipoFicha.Pelota.destinoX - ficha.x, TipoFicha.Pelota.destinoY - ficha.y);
        if (DeltaOrigen.X < 0)
            DeltaOrigen.X *= -1;
        if (DeltaOrigen.Y < 0)
            DeltaOrigen.Y *= -1;
        
        FVector2D DeltaDestino = FVector2D(TipoFicha.Pelota.destinoX - destinoX, TipoFicha.Pelota.destinoY - destinoY);
        if (DeltaDestino.X < 0)
            DeltaDestino.X *= -1;
        if (DeltaDestino.Y < 0)
            DeltaDestino.Y *= -1;
        
        if (ficha != TipoFicha.Pelota && DeltaOrigen.X <= 1 && DeltaOrigen.Y <= 1 && (DeltaDestino.X > 1 || DeltaDestino.Y > 1))
        {
            mensaje = "No se puede perder la neutralidad de la pelota";
            //mensajeError(mensaje);
            
            return false;
        }*/
        
        /// Determinar dirección
        int direccionDestinoX = 0;
        int direccionDestinoY = 0;
        
        // destinoX
        if (ficha.x < destinoX)
            direccionDestinoX = 1;
        else if (ficha.x > destinoX)
            direccionDestinoX = -1;
        
        // destinoY
        if (ficha.y < destinoY)
            direccionDestinoY = 1;
        else if (ficha.y > destinoY)
            direccionDestinoY = -1;
        
        destinoX = ficha.x;
        destinoY = ficha.y;
        
        int cantidadMovimientos = 1 + deltaDestinoY ? deltaDestinoX : deltaDestinoY;
        for (int i = 1; i < cantidadMovimientos; i++)
        {
            destinoX += direccionDestinoX;
            destinoY += direccionDestinoY;
            
            if (board[destinoX, destinoY] != TipoFicha.Vacio)
            {
                // En caso de ser la pelota debe saltar fichas
                if (ficha.ficha == TipoFicha.Pelota &&
                    destino != null &&
                    destino.ficha != null &&
                    destino.ficha.equipo != turno)
                {
                    mensaje = "El arquero atajaria ese tiro";
                    //mensajeError(mensaje);
                    return false;
                } else if (ficha.ficha != PELOTA && 
                    destino != null &&
                    destino.ficha != null &&
                    Casillas [destinoX, Columna].ficha.x == destinoX &&
                    Casillas [Fila, Columna]->Ficha->Columna == Columna)
                {
                    Mensaje = "No se puede atravesar a otros jugadores";
                    PlayerController->ActualizarMensaje(Mensaje, false);
                    return false;
                }
            }
        }
        
        return true;
    }

    // Obtiene el estado de la celda indicada
    BoardCell obtenerEstadoCelda(int Fila, int Columna)
    {
        BoardCell ficha = null;
        
        for (int i = (Fila - 1); i <= (Fila + 1); i++)
        {
            for (int j = (Columna - 1); j <= (Columna + 1); j++)
            {
                if ((i != Fila || j != Columna) &&
                    i > 0 && i < (alto - 1) &&
                    j >= 0 && j < ancho &&
                    board[i,j] != null &&
                    obtenerEquipo(board[i,j].ficha) == turno)
                {
                    if (ficha == null)
                    {
                        ficha = board[i,j];
                    }
                    else
                    {
                        ficha = null;
                        return ficha;
                    }
                }
            }
        }
        
        return ficha;
    }

    // Modifica la influencia de las casillas adyacentes a una posicion
    void modificarInfluencia(int x, int y, bool inverso)
    {
        for (int i = (x - 1); i <= (x + 1); i++)
        {
            for (int j = (y - 1); j <= (y + 1); j++)
            {
                if ((i != x || j != y) &&
                    i > 0 && i < (alto - 2) &&
                    j >= 0 && j < ancho)
                {
                    board [i, j].modificarInfluencia(board [x, y].ficha, inverso);
                }
            }
        }
    }

    Equipo obtenerEquipo(TipoFicha ficha)
    {
        if (ficha == TipoFicha.BlancoFicha || ficha == TipoFicha.BlancoArquero)
        {
            return Equipo.Blanco;
        }
        else if (ficha == TipoFicha.RojoFicha || ficha == TipoFicha.RojoArquero)
        {
            return Equipo.Rojo;
        }
        else
        {
            return Equipo.Ninguno;
        }
    }

    // Verifica si la pelota se encuentra alrededor de la ficha
    bool getBall(int x, int y)
    {
        // En caso de que la ficha se encuentre en un limite de la matriz
        if (x == 0)
        {
            if (board [x, y - 1].ficha == TipoFicha.Pelota || board [x, y + 1].ficha == TipoFicha.Pelota || board [x + 1, y + 1].ficha == TipoFicha.Pelota ||
                board [x + 1, y].ficha == TipoFicha.Pelota || board [x + 1, y - 1].ficha == TipoFicha.Pelota 
                )
                return true;
        }
        if (x == 14)
        {
            if (board [x, y - 1].ficha == TipoFicha.Pelota || board [x - 1, y - 1].ficha == TipoFicha.Pelota || board [x - 1, y].ficha == TipoFicha.Pelota || 
                board [x - 1, y + 1].ficha == TipoFicha.Pelota || board [x, y + 1].ficha == TipoFicha.Pelota 
                )
                return true;        
        }
        if (y == 0)
        {
            if (board [x - 1, y].ficha == TipoFicha.Pelota || board [x - 1, y + 1].ficha == TipoFicha.Pelota || board [x, y + 1].ficha == TipoFicha.Pelota || 
                board [x + 1, y + 1].ficha == TipoFicha.Pelota || board [x + 1, y].ficha == TipoFicha.Pelota 
                )
                return true;
        }
        if (y == 10)
        {
            if (board [x, y - 1].ficha == TipoFicha.Pelota || board [x - 1, y - 1].ficha == TipoFicha.Pelota || board [x - 1, y].ficha == TipoFicha.Pelota || 
                board [x + 1, y].ficha == TipoFicha.Pelota || board [x + 1, y - 1].ficha == TipoFicha.Pelota 
                )
                return true;
        }
        // En caso de que la ficha no se encuentre en un limite de la matriz
        if (x != 0 && x != 14 && y != 0 && y != 10)
        {
            if (board [x, y - 1].ficha == TipoFicha.Pelota || board [x - 1, y - 1].ficha == TipoFicha.Pelota || board [x - 1, y].ficha == TipoFicha.Pelota || 
                board [x - 1, y + 1].ficha == TipoFicha.Pelota || board [x, y + 1].ficha == TipoFicha.Pelota || board [x + 1, y + 1].ficha == TipoFicha.Pelota ||
                board [x + 1, y].ficha == TipoFicha.Pelota || board [x + 1, y - 1].ficha == TipoFicha.Pelota 
                )
                return true;
        }
        return false; 
    }

    // Carga el nuevo movimiento en la matriz
    [RPC]
    void setMatrix(int fichaX, int fichaY, int destinoX, int destinoY)
    {
        board [destinoX, destinoY].ficha = board [fichaX, fichaY].ficha;
        board [fichaX, fichaY].ficha = TipoFicha.Vacio; 
    }

    // Mueve la pelota en el servidor y en el cliente
    /* Esto se hace porque el servidor es el que instancio la pelota y por ende cuando el cliente mueve la pelota
    los cambios no se ven en el servidor*/
    [RPC]
    void moveBallOnServerAndClient(int destX, int destY, Vector3 pos, int origX, int origY)
    {
        GameObject.FindWithTag("BALL").GetComponent<MatrixAttributes>().x = destX; 
        GameObject.FindWithTag("BALL").GetComponent<MatrixAttributes>().y = destY;
        // Muevo la pelota
        GameObject.FindWithTag("BALL").transform.position = pos;
        GameObject.FindWithTag("BALL").GetComponent<Renderer>().material.color = Color.yellow;
        // Actualizo la matriz (hardcoded porque no andaba llamando a setMatrix)
        // No anda llamando a setMatrix porque esta funcion ya se ejecuta en el servidor
        selected = null;
        ballSelected = false;
        board [destX, destY].ficha = TipoFicha.Pelota;
        board [origX, origY].ficha = TipoFicha.Vacio;   
    }

    /*
    // Para manejo de turnos
    [RPC]
    void setTurn ()
    {
        if (turn == 1) {
            turn = 2;
        } else {
            turn = 1;
        }
    }
    */

}
